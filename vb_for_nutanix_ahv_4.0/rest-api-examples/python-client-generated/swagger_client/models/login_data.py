# coding: utf-8

"""
    Veeam Backup for Nutanix AHV REST API 4.0

    This REST API reference lists types of Veeam Backup for Nutanix AHV entities,  and contains description of collections and resources which stand for these entities.  Every resource has a JSON object model and includes application data and REST API metadata.  Application data is represented by properties associated with Veeam Backup for Nutanix AHV entities.  REST API metadata is represented by properties specific to the REST API, such as resource IDs, URLs and relationships.  The reference also includes methods that represent operations available to a resource or collection.   # noqa: E501

    OpenAPI spec version: V4
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class LoginData(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'grant_type': 'GrantType',
        'user_name': 'str',
        'password': 'str',
        'refresh_token': 'str',
        'updater_token': 'str',
        'long_lived_refresh_token': 'bool'
    }

    attribute_map = {
        'grant_type': 'grantType',
        'user_name': 'userName',
        'password': 'password',
        'refresh_token': 'refreshToken',
        'updater_token': 'updaterToken',
        'long_lived_refresh_token': 'longLivedRefreshToken'
    }

    def __init__(self, grant_type=None, user_name=None, password=None, refresh_token=None, updater_token=None, long_lived_refresh_token=False):  # noqa: E501
        """LoginData - a model defined in Swagger"""  # noqa: E501
        self._grant_type = None
        self._user_name = None
        self._password = None
        self._refresh_token = None
        self._updater_token = None
        self._long_lived_refresh_token = None
        self.discriminator = None
        self.grant_type = grant_type
        if user_name is not None:
            self.user_name = user_name
        if password is not None:
            self.password = password
        if refresh_token is not None:
            self.refresh_token = refresh_token
        if updater_token is not None:
            self.updater_token = updater_token
        if long_lived_refresh_token is not None:
            self.long_lived_refresh_token = long_lived_refresh_token

    @property
    def grant_type(self):
        """Gets the grant_type of this LoginData.  # noqa: E501


        :return: The grant_type of this LoginData.  # noqa: E501
        :rtype: GrantType
        """
        return self._grant_type

    @grant_type.setter
    def grant_type(self, grant_type):
        """Sets the grant_type of this LoginData.


        :param grant_type: The grant_type of this LoginData.  # noqa: E501
        :type: GrantType
        """
        if grant_type is None:
            raise ValueError("Invalid value for `grant_type`, must not be `None`")  # noqa: E501

        self._grant_type = grant_type

    @property
    def user_name(self):
        """Gets the user_name of this LoginData.  # noqa: E501

        \\[Required if the `grant_type` parameter value is *Password*\\] User name.  # noqa: E501

        :return: The user_name of this LoginData.  # noqa: E501
        :rtype: str
        """
        return self._user_name

    @user_name.setter
    def user_name(self, user_name):
        """Sets the user_name of this LoginData.

        \\[Required if the `grant_type` parameter value is *Password*\\] User name.  # noqa: E501

        :param user_name: The user_name of this LoginData.  # noqa: E501
        :type: str
        """

        self._user_name = user_name

    @property
    def password(self):
        """Gets the password of this LoginData.  # noqa: E501

        \\[Required if the `grant_type` parameter value is *Password*\\] Password of the user.  # noqa: E501

        :return: The password of this LoginData.  # noqa: E501
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password):
        """Sets the password of this LoginData.

        \\[Required if the `grant_type` parameter value is *Password*\\] Password of the user.  # noqa: E501

        :param password: The password of this LoginData.  # noqa: E501
        :type: str
        """

        self._password = password

    @property
    def refresh_token(self):
        """Gets the refresh_token of this LoginData.  # noqa: E501

        \\[Required if the `grant_type` parameter value is *RefreshToken*\\] Refresh token.  # noqa: E501

        :return: The refresh_token of this LoginData.  # noqa: E501
        :rtype: str
        """
        return self._refresh_token

    @refresh_token.setter
    def refresh_token(self, refresh_token):
        """Sets the refresh_token of this LoginData.

        \\[Required if the `grant_type` parameter value is *RefreshToken*\\] Refresh token.  # noqa: E501

        :param refresh_token: The refresh_token of this LoginData.  # noqa: E501
        :type: str
        """

        self._refresh_token = refresh_token

    @property
    def updater_token(self):
        """Gets the updater_token of this LoginData.  # noqa: E501

        \\[Required if the `grant_type` parameter value is *UpdaterToken*\\] Updater token.  # noqa: E501

        :return: The updater_token of this LoginData.  # noqa: E501
        :rtype: str
        """
        return self._updater_token

    @updater_token.setter
    def updater_token(self, updater_token):
        """Sets the updater_token of this LoginData.

        \\[Required if the `grant_type` parameter value is *UpdaterToken*\\] Updater token.  # noqa: E501

        :param updater_token: The updater_token of this LoginData.  # noqa: E501
        :type: str
        """

        self._updater_token = updater_token

    @property
    def long_lived_refresh_token(self):
        """Gets the long_lived_refresh_token of this LoginData.  # noqa: E501

        Defines whether the expiration time of the refresh token is increased to 14 days.  # noqa: E501

        :return: The long_lived_refresh_token of this LoginData.  # noqa: E501
        :rtype: bool
        """
        return self._long_lived_refresh_token

    @long_lived_refresh_token.setter
    def long_lived_refresh_token(self, long_lived_refresh_token):
        """Sets the long_lived_refresh_token of this LoginData.

        Defines whether the expiration time of the refresh token is increased to 14 days.  # noqa: E501

        :param long_lived_refresh_token: The long_lived_refresh_token of this LoginData.  # noqa: E501
        :type: bool
        """

        self._long_lived_refresh_token = long_lived_refresh_token

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LoginData, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LoginData):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
